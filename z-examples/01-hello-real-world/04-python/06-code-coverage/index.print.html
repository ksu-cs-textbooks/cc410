<!DOCTYPE html>

<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="print">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.148.1">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="YouTube Video We’ve now written our program, as well as a unit test that runs our program and make sure it works. But, how can we be sure that our unit tests are adequately testing every part of our program? For that, we have to rely on another tool to help us calculate the code coverage of our unit tests.
Install Coverage.py Thankfully, there are many easy to use tools that will compute the code coverage of a set of tests. For Python, one of the most commonly used tools is the aptly-named Coverage.py. Coverage.py is a free code coverage library designed for Python, and it is easy to install.">
    <meta name="author" content="Russell Feldhausen">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cc410/images/hero.png">
    <meta name="twitter:title" content="Code Coverage :: CC 410 Textbook">
    <meta name="twitter:description" content="YouTube Video We’ve now written our program, as well as a unit test that runs our program and make sure it works. But, how can we be sure that our unit tests are adequately testing every part of our program? For that, we have to rely on another tool to help us calculate the code coverage of our unit tests.
Install Coverage.py Thankfully, there are many easy to use tools that will compute the code coverage of a set of tests. For Python, one of the most commonly used tools is the aptly-named Coverage.py. Coverage.py is a free code coverage library designed for Python, and it is easy to install.">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-python/06-code-coverage/index.html">
    <meta property="og:site_name" content="CC 410 Textbook">
    <meta property="og:title" content="Code Coverage :: CC 410 Textbook">
    <meta property="og:description" content="YouTube Video We’ve now written our program, as well as a unit test that runs our program and make sure it works. But, how can we be sure that our unit tests are adequately testing every part of our program? For that, we have to rely on another tool to help us calculate the code coverage of our unit tests.
Install Coverage.py Thankfully, there are many easy to use tools that will compute the code coverage of a set of tests. For Python, one of the most commonly used tools is the aptly-named Coverage.py. Coverage.py is a free code coverage library designed for Python, and it is easy to install.">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="Example Projects">
    <meta property="article:modified_time" content="2024-06-17T14:13:48-05:00">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cc410/images/hero.png">
    <meta itemprop="name" content="Code Coverage :: CC 410 Textbook">
    <meta itemprop="description" content="YouTube Video We’ve now written our program, as well as a unit test that runs our program and make sure it works. But, how can we be sure that our unit tests are adequately testing every part of our program? For that, we have to rely on another tool to help us calculate the code coverage of our unit tests.
Install Coverage.py Thankfully, there are many easy to use tools that will compute the code coverage of a set of tests. For Python, one of the most commonly used tools is the aptly-named Coverage.py. Coverage.py is a free code coverage library designed for Python, and it is easy to install.">
    <meta itemprop="dateModified" content="2024-06-17T14:13:48-05:00">
    <meta itemprop="wordCount" content="1708">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cc410/images/hero.png">
    <title>Code Coverage :: CC 410 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-python/06-code-coverage/index.html" rel="canonical" type="text/html" title="Code Coverage :: CC 410 Textbook">
    <link href="/cc410/z-examples/01-hello-real-world/04-python/06-code-coverage/index.xml" rel="alternate" type="application/rss+xml" title="Code Coverage :: CC 410 Textbook">
    <link href="/cc410/z-examples/01-hello-real-world/04-python/06-code-coverage/tele.html" rel="alternate" type="text/html" title="Code Coverage :: CC 410 Textbook">
    <link href="/cc410/z-examples/01-hello-real-world/04-python/06-code-coverage/embed.html" rel="alternate" type="text/html" title="Code Coverage :: CC 410 Textbook">
    <link href="/cc410/images/favicon.ico?1755708720" rel="icon" type="image/x-icon" sizes="any">
    <link href="/cc410/css/auto-complete/auto-complete.min.css?1755708720" rel="stylesheet">
    <script src="/cc410/js/auto-complete/auto-complete.min.js?1755708720" defer></script>
    <script src="/cc410/js/search-lunr.min.js?1755708720" defer></script>
    <script src="/cc410/js/search.min.js?1755708720" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cc410/searchindex.en.js?1755708720";
    </script>
    <script src="/cc410/js/lunr/lunr.min.js?1755708720" defer></script>
    <script src="/cc410/js/lunr/lunr.stemmer.support.min.js?1755708720" defer></script>
    <script src="/cc410/js/lunr/lunr.multi.min.js?1755708720" defer></script>
    <script src="/cc410/js/lunr/lunr.en.min.js?1755708720" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cc410/fonts/fontawesome/css/fontawesome-all.min.css?1755708720" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc410/fonts/fontawesome/css/fontawesome-all.min.css?1755708720" rel="stylesheet"></noscript>
    <link href="/cc410/css/perfect-scrollbar/perfect-scrollbar.min.css?1755708720" rel="stylesheet">
    <link href="/cc410/css/theme.min.css?1755708720" rel="stylesheet">
    <link href="/cc410/css/format-print.min.css?1755708720" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/z-examples\/01-hello-real-world\/04-python\/06-code-coverage\/index.html';
      window.relearn.relBasePath='..\/..\/..\/..';
      window.relearn.relBaseUri='..\/..\/..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc410';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cc410/css/custom.css?1755708720" rel="stylesheet">
  </head>
  <body class="mobile-support print" data-url="/cc410/z-examples/01-hello-real-world/04-python/06-code-coverage/index.html">
    
    <div id="tele" class="tele mirror">
    
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable z-examples" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="code-coverage">Code Coverage</h1>


<a href="https://www.youtube.com/watch?v=jB6VoijiOVo">YouTube Video</a>

<p>We&rsquo;ve now written our program, as well as a unit test that runs our program and make sure it works. But, how can we be sure that our unit tests are adequately testing every part of our program? For that, we have to rely on another tool to help us calculate the <strong>code coverage</strong> of our unit tests.</p>
<h2 id="install-coveragepy">Install Coverage.py</h2>
<p>Thankfully, there are many easy to use tools that will compute the code coverage of a set of tests. For Python, one of the most commonly used tools is the aptly-named Coverage.py. <a href="https://coverage.readthedocs.io/en/coverage-5.3.1/" rel="external" target="_blank">Coverage.py</a> is a free code coverage library designed for Python, and it is easy to install.</p>
<p>As we&rsquo;ve already learned, we could easily install it using <code>pip</code>. However, since we are now using tox and a requirements file, we need to make sure that we update our requirements file as well. One easy way to do that is to just update the requirements file to include the new library, then use <code>pip</code> to make sure everything is installed properly.</p>
<p>So, let&rsquo;s open <code>requirements.txt</code> and make sure it now includes the following content:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-tex" data-lang="tex"><span style="display:flex;"><span>coverage
</span></span><span style="display:flex;"><span>pytest
</span></span><span style="display:flex;"><span>pytest-html
</span></span><span style="display:flex;"><span>tox</span></span></code></pre></div>
<p>Once we&rsquo;ve updated our requirements file, we can then install it by opening a Linux terminal, going to the <code>python</code> folder, and then using <code>pip</code> to install everything from the requirements list:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>pip3 install -r requirements.txt</span></span></code></pre></div>
<p>As you might guess, the <code>-r</code> command line argument for <code>pip3</code> will allow us to install the requirements listed in a requirements file. Once we run that command, the last line of output will list the packages installed, and we should see that Coverage.py is now installed:</p>
<p><a href="#R-image-de01b13da3e0db87f7cffb2de66c6b2a" class="lightbox-link"><img alt="Install Coverage" class="border lazy lightbox figure-image" loading="lazy" src="/cc410/images/e1/25installcov.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-de01b13da3e0db87f7cffb2de66c6b2a"><img alt="Install Coverage" class="border lazy lightbox lightbox-image" loading="lazy" src="/cc410/images/e1/25installcov.png"></a></p>
<h2 id="compute-code-coverage-with-coveragepy">Compute Code Coverage with Coverage.py</h2>
<p>Now that we&rsquo;ve installed and configured Coverage.py, let&rsquo;s execute it and see what happens. Coverage.py uses a two step process to compute the code coverage from a set of tests - first we must execute the tests using the Coverage.py tool, then we can use another command to generate a report. So, from within the <code>python</code> folder, we can run the following command:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>python3 -m coverage run --source src -m pytest --html<span style="color:#f92672">=</span>reports/pytest/index.html</span></span></code></pre></div>
<p>This command is getting pretty complex, so let&rsquo;s break it down:</p>
<ul>
<li><code>python3</code> - as always, we are running these commands using Python 3. From here onward, we&rsquo;ll run each library as as module in Python instead of running the commands themselves.</li>
<li><code>-m coverage run</code> - we want to execute the Coverage.py <code>run</code> command. We use <code>-m</code> to tell Python that we are executing the Coverage.py library as a Python module</li>
<li><code>--source src</code> - this tells Coverage.py where our source code is located. It will compute the coverage only for files in that directory</li>
<li><code>-m pytest</code> - we also have to tell Coverage.py how to execute the tests, so we include a second <code>-m</code> followed by <code>pytest</code>. Basically, we are taking our existing command for pytest and adding a few bits in front of it for Coverage.py</li>
<li><code>--html=reports/pytest/index.html</code> - as we saw earlier, this will tell pytest to create and store a report of the test results.</li>
</ul>
<p>When we execute that command, it will tell Python to run our unit tests and generate a test report. Since we are now using Coverage.py to compute code coverage, we&rsquo;ll also see a new file appear, named <code>.coverage</code>:</p>
<p><a href="#R-image-5d03f79ea269d41352c75a59844ada1f" class="lightbox-link"><img alt="Dot Coverage File" class="border lazy lightbox figure-image" loading="lazy" src="/cc410/images/e1/25dotcov.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-5d03f79ea269d41352c75a59844ada1f"><img alt="Dot Coverage File" class="border lazy lightbox lightbox-image" loading="lazy" src="/cc410/images/e1/25dotcov.png"></a></p>
<p>This file contains the data the Coverage.py collected from the unit tests. If needed, we can run multiple sets of unit tests and combine the data files using other Coverage.py commands. However, for now we won&rsquo;t worry about that.</p>
<p>Once we&rsquo;ve run our unit tests, we need to run one more command to generate a report. So, once again from within the <code>python</code> directory, run the following command:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>python3 -m coverage html -d reports/coverage</span></span></code></pre></div>
<p>The <code>coverage html</code> command will generate a report, and the <code>-d</code> command line option sets the directory where the report will be stored. Once we execute this command, we should see the <code>coverage</code> directory structure appear in <code>reports</code>:</p>
<p><a href="#R-image-8164a2cad910f4e6d8424b494c8475e6" class="lightbox-link"><img alt="Coverage Report Structure" class="border lazy lightbox figure-image" loading="lazy" src="/cc410/images/e1/25covreport.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-8164a2cad910f4e6d8424b494c8475e6"><img alt="Coverage Report Structure" class="border lazy lightbox lightbox-image" loading="lazy" src="/cc410/images/e1/25covreport.png"></a></p>
<p>Inside of that folder is another <code>index.html</code> file. So, let&rsquo;s <strong>right-click</strong> it and select <strong>Preview Static</strong> to open it as a webpage. Hopefully we should see something like this:</p>
<p><a href="#R-image-b0cefff9d0fb58b74b40139254590f89" class="lightbox-link"><img alt="Coverage Report" class="border lazy lightbox figure-image" loading="lazy" src="/cc410/images/e1/25covhtml.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-b0cefff9d0fb58b74b40139254590f89"><img alt="Coverage Report" class="border lazy lightbox lightbox-image" loading="lazy" src="/cc410/images/e1/25covhtml.png"></a></p>
<p>While our test only reports that it achieved 56% code coverage, we can see that it is because the <code>__main__.py</code> file was not executed. If we look at the other source files, we&rsquo;ll see that we achieved 100% code coverage with our tests! That&rsquo;s the goal, though it was pretty easy to achieve when our application really only contains one line of code. By clicking the links on the page, we can even see which lines are tested by our program, as shown below:</p>
<p><a href="#R-image-95ab6d10a656b261ec33ce551df7f97c" class="lightbox-link"><img alt="Coverage Highlight" class="border lazy lightbox figure-image" loading="lazy" src="/cc410/images/e1/25hello.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-95ab6d10a656b261ec33ce551df7f97c"><img alt="Coverage Highlight" class="border lazy lightbox lightbox-image" loading="lazy" src="/cc410/images/e1/25hello.png"></a></p>
<h2 id="code-coverage-in-tox">Code Coverage in Tox</h2>
<p>Now that we have our Coverage.py library working, let&rsquo;s update our tox configuration file to allow us to run those commands automatically via tox. All we have to do is open <code>tox.ini</code> in the <code>python</code> folder and update the <code>commands</code> section at the end of the file to look like this:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-ini" data-lang="ini"><span style="display:flex;"><span><span style="color:#a6e22e">commands</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">python3 -m coverage run --source src -m pytest --html=reports/pytest/index.html
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">           python3 -m coverage html -d reports/coverage</span></span></span></code></pre></div>
<p>Notice that those are the exact same commands we used earlier to execute our tests and generate a report using Coverage.py. That&rsquo;s one of the most powerful features of tox - you are able to use the same commands within tox that you would use to manually execute the program.</p>
<p>Once we&rsquo;ve updated <code>tox.ini</code>, let&rsquo;s run it once to make sure it works. This time, since we&rsquo;ve installed a new requirement, we&rsquo;ll need to tell tox to rebuild its environment by using the <code>-r</code> command line flag:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>tox -r</span></span></code></pre></div>
<p>That will tell tox to completely rebuild its virtual environment and reinstall any libraries listed in the requirements file.</p>
<p>We should once again be able to see tox execute our tests and generate a report:</p>
<p><a href="#R-image-67a4719ec0b8e2abf4beecc3d79353a3" class="lightbox-link"><img alt="Tox Rebuild" class="border lazy lightbox figure-image" loading="lazy" src="/cc410/images/e1/25toxrebuild.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-67a4719ec0b8e2abf4beecc3d79353a3"><img alt="Tox Rebuild" class="border lazy lightbox lightbox-image" loading="lazy" src="/cc410/images/e1/25toxrebuild.png"></a></p>
<h2 id="more-complex-code">More Complex Code</h2>
<p>Let&rsquo;s modify our application a bit and see how we can use Coverage.py to make sure we are really testing everything our application can do. In the <code>HelloWorld.py</code> file, found in <code>src/hello</code>, replace the existing code with this code:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HelloWorld</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@staticmethod</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">main</span>(args):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(args) <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;Hello </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(args[<span style="color:#ae81ff">1</span>]))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;Hello World&#34;</span>)</span></span></code></pre></div>
<p>This program will now print &ldquo;Hello World&rdquo; if executed without any command line arguments, but if one is provided it will use that argument in the message instead. So, let&rsquo;s run our program again using this command from within the <code>python</code> folder:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>tox</span></span></code></pre></div>
<p>Once the tests have finished, we can open the Coverage.py report stored in <code>reports/coverage/index.html</code> and we should find that it no longer achieves 100% coverage:</p>
<p><a href="#R-image-f28a981d6d158495b6a228d21839e9f3" class="lightbox-link"><img alt="Coverage.py Not Full Coverage" class="border lazy lightbox figure-image" loading="lazy" src="/cc410/images/e1/26badcoverage.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-f28a981d6d158495b6a228d21839e9f3"><img alt="Coverage.py Not Full Coverage" class="border lazy lightbox lightbox-image" loading="lazy" src="/cc410/images/e1/26badcoverage.png"></a></p>
<p>If we drill down deeper, we can find the lines of code that aren&rsquo;t covered by our tests:</p>
<p><a href="#R-image-123ea54b2a3679a84675cfeb0e9edd5d" class="lightbox-link"><img alt="Coverage.py Missing Lines" class="border lazy lightbox figure-image" loading="lazy" src="/cc410/images/e1/26highlight.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-123ea54b2a3679a84675cfeb0e9edd5d"><img alt="Coverage.py Missing Lines" class="border lazy lightbox lightbox-image" loading="lazy" src="/cc410/images/e1/26highlight.png"></a></p>
<p>As we expected, our single unit test is not able to test each and every line of code in our application. That&rsquo;s not good! So, we&rsquo;ll need to update our tests to account for the change in our code.</p>

<details open class=" box cstyle notices note">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-exclamation-circle"></i> 
    Test-Driven Development
  </summary>
  <div class="box-content">
<p>As a quick aside, if we were engaging in <strong>test-driven development</strong>, we would write the new unit test before changing the code. We won&rsquo;t model that behavior right now, but it is worth noting that you don&rsquo;t have to do these steps in the order presented here.</p>
  </div>
</details>
<h2 id="update-unit-tests">Update Unit Tests</h2>
<p>So, let&rsquo;s update our unit tests to account for this new code. There are a couple of ways we can do this:</p>
<ol>
<li>We can add more code to our existing <code>test_hello_world</code> method to call the method multiple times, both with and without arguments.</li>
<li>We can add additional test methods to test different behaviors.</li>
</ol>
<p>In general, when working with unit tests, it is <strong>always</strong> preferred to add additional test methods to test additional functionality in the program. We want to keep our tests as simple and focused as possible, so that we can easily find the source of any errors it finds. If we simply added more code to the existing test, it would be difficult to tell exactly what caused the error. We&rsquo;ll cover this in more detail when we formally discuss unit testing later in this course.</p>
<p>For now, let&rsquo;s open the <code>test_HelloWorld.py</code> file stored in <code>test/hello</code> and add the following method to the <code>TestHelloWorld</code> class:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">test_hello_world_arg</span>(self, capsys):
</span></span><span style="display:flex;"><span>        HelloWorld<span style="color:#f92672">.</span>main([<span style="color:#e6db74">&#34;HelloWorld&#34;</span>, <span style="color:#e6db74">&#34;CC 410&#34;</span>])
</span></span><span style="display:flex;"><span>        captured <span style="color:#f92672">=</span> capsys<span style="color:#f92672">.</span>readouterr()
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">assert</span> captured<span style="color:#f92672">.</span>out <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;Hello CC 410</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#e6db74">&#34;Unexpected Output&#34;</span></span></span></code></pre></div>
<p>Notice that this is nearly identical to the previous unit test method - we simply changed the arguments that are provided to the <code>main</code> method, and also updated the assertion to account for the changed output we expect to receive. As discussed earlier, there are things we can do to prevent duplication of code like this in our unit tests, but we won&rsquo;t worry about that for now.</p>
<p>Once again, let&rsquo;s rerun our tests using this command:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>tox</span></span></code></pre></div>
<p>Once that is done, we can open the JaCoCo report and see if we are back to 100% coverage:</p>
<p><a href="#R-image-70c72b746df3905d499f1d0fabf071be" class="lightbox-link"><img alt="Coverage.py Fixed Coverage" class="border lazy lightbox figure-image" loading="lazy" src="/cc410/images/e1/26goodhighlight.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-70c72b746df3905d499f1d0fabf071be"><img alt="Coverage.py Fixed Coverage" class="border lazy lightbox lightbox-image" loading="lazy" src="/cc410/images/e1/26goodhighlight.png"></a></p>
<p>If everything is working correctly, we should see that we are back at 100% coverage, and each line of code in our program is tested.</p>
<p>Of course, achieving 100% code coverage does not mean that you&rsquo;ve completely tested everything that your application could possibly do - it simply means that you are <em>at least</em> testing every line of code at least once. It&rsquo;s a great baseline to start with!</p>
<h2 id="git-commit-and-push">Git Commit and Push</h2>
<p>This is a good point to stop and commit our code to our Git repository. So, like before, we&rsquo;ll start by checking the status of our Git repository to see the files we&rsquo;ve changed:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git status</span></span></code></pre></div>
<p>In that list, we should see everything we&rsquo;ve updated listed in red. Next, we&rsquo;ll add them to our index using this command:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git add .</span></span></code></pre></div>
<p>And then we can review our changes using the status command again:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git status</span></span></code></pre></div>
<p>If we are satisfied that everything looks correctly, we can commit our changes using this command:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git commit -m <span style="color:#e6db74">&#34;Unit Tests and Code Coverage&#34;</span></span></span></code></pre></div>
<p>And finally, we can push those changes to the remote repository on GitHub using this command:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git push</span></span></code></pre></div>
<p>As you can quickly see, this is a pretty short set of 5 commands that we can use to quickly store our code in our local Git repository and on GitHub. We just have to carefully pay attention to the files we commit and make sure it is correct.</p>

  <footer class="footline">
  </footer>
</article>
        </div>
      </main>
      
      
      
    </div>
    <script src="/cc410/js/clipboard/clipboard.min.js?1755708720" defer></script>
    <script src="/cc410/js/perfect-scrollbar/perfect-scrollbar.min.js?1755708720" defer></script>
    <script src="/cc410/js/theme.min.js?1755708720" defer></script>
      
      
      
    </div> 
  <script src="/cc410/js/tele-scroll.min.js?1755708720" defer></script>
  </body>
</html>
