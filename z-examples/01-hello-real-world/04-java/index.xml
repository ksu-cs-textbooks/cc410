<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java :: CC 410 Textbook</title>
    <link>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/index.html</link>
    <description>This section contains content for the Java programming language only.&#xA;Skip to Python&#xA;Skip to Creating Release</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Install Gradle</title>
      <link>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/01-install-gradle/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/01-install-gradle/index.html</guid>
      <description>tl;dr If you are reviewing this material or are familiar with these concepts, here’s the short version:&#xA;# Install tools on Ubuntu if doing this at home sudo apt update &amp;&amp; sudo apt install zip unzip curl sed # Verify Java SDK version 8 or higher java -version # Install SDKMAN! curl -s &#34;https://get.sdkman.io&#34; | bash # Install Gradle sdk install gradle 7.6 Working with Java on the Linux terminal can be complicated, especially as projects become larger and larger. Thankfully, there are many tools that have been developed to simplify this process. For this course, we’re going to use one such tool, called Gradle.</description>
    </item>
    <item>
      <title>Create New Project</title>
      <link>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/02-create-new-project/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/02-create-new-project/index.html</guid>
      <description>Once we have Gradle installed, we can use Gradle to create a scaffold for our new Java project. This is a great starting point for any Java application, but we’ll customize it a bit to suit our needs.&#xA;For this part of the project, we’ll loosely follow this guide on Building Java Applications from the Gradle documentation.</description>
    </item>
    <item>
      <title>Write Hello World</title>
      <link>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/03-write-hello-world/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/03-write-hello-world/index.html</guid>
      <description>Now, let’s write the basic source code for our “Hello Real World” application. Thankfully, we can adapt some of the code that is provided by the Gradle init command, but we’ll simplify it a bit to meet our needs.&#xA;Rename App.java First, let’s rename the App.java file in app/src/main/java/hello to HelloWorld.java. This filename is a better representation of what we want our class to be. Recall that the filenames of .java files must exactly match the name of the Java class contained in the file.</description>
    </item>
    <item>
      <title>Git Commit &amp; Push</title>
      <link>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/04-git-commit-push/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/04-git-commit-push/index.html</guid>
      <description>tl;dr If you are familiar with using Git, here is the short version:&#xA;git status git add . # check that the correct files are added git status # update the commit message below git commit -m &#34;Commit Message Here&#34; git push That will commit and push your changes to GitHub, which can now be found in the repository for this assignment.</description>
    </item>
    <item>
      <title>Unit Tests</title>
      <link>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/05-unit-tests/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/05-unit-tests/index.html</guid>
      <description>At this point, we’ve written the basic code for our “Hello World” program. However, how can we automatically verify that the source code works properly? To do that, we’ll need to create some unit tests that verify our code.&#xA;Unit Tests In our Java application, the unit tests are stored in the app/src/test/java directory. In that directory, there is a directory for hello that represents a package, just like the hello directory in the app/src/main/java where our program code lives. It is typically good practice to have packages in our unit tests that match the packages in our source code, so we’ll leave it as is.</description>
    </item>
    <item>
      <title>Code Coverage</title>
      <link>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/06-code-coverage/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/06-code-coverage/index.html</guid>
      <description>We’ve now written our program, as well as a unit test that runs our program and make sure it works. But, how can we be sure that our unit tests are adequately testing every part of our program? For that, we have to rely on another tool to help us calculate the code coverage of our unit tests.</description>
    </item>
    <item>
      <title>Documentation</title>
      <link>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/07-documentation/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/07-documentation/index.html</guid>
      <description>The next step in writing good code is adding proper documentation and comments to describe the code and what it does. By writing good documentation, we can pass on helpful information to other developers who need to maintain this code, including our future selves!&#xA;Javadoc The Java platform includes a tool called Javadoc that can be used to generate documentation directly from the comments in a piece of source code. A great example that we already explored in the textbook is the entire Java API Documentation, which is generated directly from the Java source code using Javadoc. For instance, you can compare the comments at the top of the ArrayList source code file:</description>
    </item>
    <item>
      <title>Checkstyle</title>
      <link>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/08-checkstyle/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/08-checkstyle/index.html</guid>
      <description>Finally, we’re at the point that we’ve written our application, a couple of unit tests, verified that the unit tests achieve a high level of code coverage, and we’ve written helpful documentation comments in our code. That’s a lot of content we’ve written, especially in our source code files. Now let’s see how good our coding style is by checking it using a linter.</description>
    </item>
    <item>
      <title>Hamcrest</title>
      <link>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/09-hamcrest/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/z-examples/01-hello-real-world/04-java/09-hamcrest/index.html</guid>
      <description>Let’s introduce one more useful tool as part of this example, the Hamcrest assertion library. Hamcrest is a library of unit test assertions that is available for multiple programming languages, including both Java and Python. Hamcrest makes it easy to write very advanced assertions in a way that is both readable and flexible. In fact, most of the autograders in prior CC courses use Hamcrest as the primary assertion library to make them easy to develop. Let’s explore what it takes to add Hamcrest to our project.</description>
    </item>
  </channel>
</rss>