<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Parallelism :: CC 410 Textbook</title>
    <link>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/index.html</link>
    <description>Running multiple threads concurrently!</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 17 Jun 2024 14:13:48 -0500</lastBuildDate>
    <atom:link href="https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/01-introduction/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/01-introduction/index.html</guid>
      <description>Up to this point, we’ve only been dealing with programs that run within a single thread of execution. That means that we can follow a single path through the code, all the way from the start of the program when it calls the main() method all the way to the end. Unfortunately, while this allows us to create many useful programs, we aren’t able to take advantage of the power of modern computers with multi-core processors, which can handle multiple tasks simultaneously.</description>
    </item>
    <item>
      <title>Processes</title>
      <link>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/02-processes/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/02-processes/index.html</guid>
      <description>Video Materials&#xA;First, let’s review how modern computers actually handle running multiple applications at once, and what that means for our own programs.&#xA;Process 1&#xA;When a program is executed on a computer, the operating system loads its code into memory and creates a process to handle running that program. A process is simply an instance of a computer program that is running, just like an object is an instance of a class. Some programs, such as a web browser, allow us to create multiple processes of the same program, usually represented by multiple windows or tabs. The image above shows the htop command in Linux, which lists all of the processes running on the system. In Codio, we can use the top command in the Terminal to see the running processes - go ahead and try it!</description>
    </item>
    <item>
      <title>Threads</title>
      <link>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/03-threads/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/03-threads/index.html</guid>
      <description>1&#xA;In most modern operating systems, a process can be further divided into threads, which are individual sequences of instructions that the program can follow. A great way to think of a thread is an individual line of code that you can trace through your program, starting at the beginning and going all the way to the end. Up to this point, we’ve only written programs that contain a single thread, so you should only be able to trace a single line of code all the way through the program.</description>
    </item>
    <item>
      <title>Creating Threads</title>
      <link>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/04-creating-threads/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/04-creating-threads/index.html</guid>
      <description>Video Materials&#xA;Now that we’ve learned about threads, let’s discuss how we can work with them in our programs. Writing a multithreaded program can be significantly more difficult than a single threaded program, but with the extra difficulty comes the ability to write programs that are much more flexible and powerful.</description>
    </item>
    <item>
      <title>Race Conditions</title>
      <link>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/05-race-conditions/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/05-race-conditions/index.html</guid>
      <description>Video Materials&#xA;Unfortunately, the big takeaways we saw on the previous page have very important consequences for our multithreaded programs. One of the most common errors, and also one of the notoriously most difficult errors to debug, is a race condition.&#xA;Race Condition A race condition occurs when two threads in a program are trying to update the same value at the same time. If the operating system decides to interrupt one thread at just the wrong time, then a race condition occurs and the value could be given an incorrect value.</description>
    </item>
    <item>
      <title>Thread Synchronization</title>
      <link>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/06-thread-synchronization/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/06-thread-synchronization/index.html</guid>
      <description>Video Materials&#xA;To deal with race conditions, we have to somehow synchronize our threads so that only one is able to update the value of a shared variable at once. There are many ways to do this, and they all fit under the banner of thread synchronization.&#xA;Locks The simplest way to do this is via a special programming construct called a lock. A lock can be thought of as a single object in memory that, when a thread has acquired the lock, it can access the shared memory protected by the lock. Once it is done, then it can release the lock, allowing another thread to acquire it.</description>
    </item>
    <item>
      <title>Java Threads</title>
      <link>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/07-java-threads/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/07-java-threads/index.html</guid>
      <description>Java includes several methods for creating threads. The simplest and most flexible is to implement the Runnable interface in a class, and then create a new Thread that uses an instance of the class implementing Runnable as it’s target.&#xA;It is also possible to create a class that inherits from the Thread class, which itself implements the Runnable interface. However, this is not recommended unless you need to perform more advanced work within the thread.</description>
    </item>
    <item>
      <title>Java Synchronization</title>
      <link>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/08-java-synchronization/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/08-java-synchronization/index.html</guid>
      <description>Next, let’s look at a quick example of a race condition in Java, just so we can see how it could occur in our code.&#xA;Poorly Designed Multithreading First, let’s consider this example:&#xA;public class MyData { public int x; } import java.lang.Runnable; import java.lang.Thread; import java.lang.InterruptedException; public class MyThread implements Runnable { private String name; private static MyData data; /** * Constructor. * * @param name the name of the thread */ public MyThread(String name) { this.name = name; } /** * Thread method. * * &lt;p&gt;This is called when the thread is started. */ @Override public void run() { for (int i = 0; i &lt; 3; i++) { int y = data.x; // tell the OS it is ok to switch to another thread here Thread.yield(); data.x = y + 1; System.out.println(this.name + &#34; : data.x = &#34; + data.x); } } /** * Main Method. */ public static void main(String[] args) { // create data data = new MyData(); // create threads Thread thread1 = new Thread(new MyThread(&#34;Thread 1&#34;)); Thread thread2 = new Thread(new MyThread(&#34;Thread 2&#34;)); Thread thread3 = new Thread(new MyThread(&#34;Thread 3&#34;)); // start threads System.out.println(&#34;main: starting threads&#34;); thread1.start(); thread2.start(); thread3.start(); // wait until all threads have terminated System.out.println(&#34;main: joining threads&#34;); try { thread1.join(); thread2.join(); thread3.join(); } catch (InterruptedException e){ System.out.println(&#34;main thread was interrupted&#34;); } System.out.println(&#34;main: all threads terminated&#34;); System.out.println(&#34;main: data.x = &#34; + data.x); } } Explanation In this example, we are creating a static instance of the MyData class, which can act as a shared memory object for this example. Then, in each of the threads, we are performing this three-step process:</description>
    </item>
    <item>
      <title>Python Threads</title>
      <link>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/09-python-threads/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/09-python-threads/index.html</guid>
      <description>Python includes several methods for creating threads. The simplest and most flexible is to create a new Thread object using the threading library. When that object is created, we can give it a function to use as a starting point for the thread.&#xA;Here’s a quick example of threads in Python:&#xA;import threading import time import sys class MyThread: def __init__(self, name): &#34;&#34;&#34;Constructor. Args: name: the name of the thread &#34;&#34;&#34; self.__name = name def run(self): &#34;&#34;&#34;Thread method.&#34;&#34;&#34; for i in range(0, 3): print(&#34;{} : iteration {}&#34;.format(self.__name, i)) # tell the OS to wake this thread up after at least 1 second time.sleep(1) @staticmethod def main(args): # create threads t1_object = MyThread(&#34;Thread 1&#34;) thread1 = threading.Thread(target=t1_object.run) t2_object = MyThread(&#34;Thread 2&#34;) thread2 = threading.Thread(target=t2_object.run) t3_object = MyThread(&#34;Thread 3&#34;) thread3 = threading.Thread(target=t3_object.run) # start threads print(&#34;main: starting threads&#34;) thread1.start() thread2.start() thread3.start() # wait until all threads have terminated print(&#34;main: joining threads&#34;) thread1.join() thread2.join() thread3.join() print(&#34;main: all threads terminated&#34;) # main guard if __name__ == &#34;__main__&#34;: MyThread.main(sys.argv) Let’s look at this code piece by piece so we fully understand how it works.</description>
    </item>
    <item>
      <title>Python Synchronization</title>
      <link>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/10-python-synchronization/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/10-python-synchronization/index.html</guid>
      <description>Next, let’s look at a quick example of a race condition in Python, just so we can see how it could occur in our code.&#xA;Poorly Designed Multithreading First, let’s consider this example:&#xA;import threading import time import sys class MyData: def __init__(self): self.x = 0 class MyThread: data = MyData() def __init__(self, name): &#34;&#34;&#34;Constructor. Args: name: the name of the thread &#34;&#34;&#34; self.__name = name def run(self): &#34;&#34;&#34;Thread method.&#34;&#34;&#34; for i in range(0, 3): y = MyThread.data.x # tell the OS it is ok to switch to another thread here time.sleep(0) MyThread.data.x = y + 1 print(&#34;{} : data.x = {}&#34;.format(self.__name, MyThread.data.x)) @staticmethod def main(args): # create threads t1_object = MyThread(&#34;Thread 1&#34;) thread1 = threading.Thread(target=t1_object.run) t2_object = MyThread(&#34;Thread 2&#34;) thread2 = threading.Thread(target=t2_object.run) t3_object = MyThread(&#34;Thread 3&#34;) thread3 = threading.Thread(target=t3_object.run) # start threads print(&#34;main: starting threads&#34;) thread1.start() thread2.start() thread3.start() # wait until all threads have terminated print(&#34;main: joining threads&#34;) thread1.join() thread2.join() thread3.join() print(&#34;main: all threads terminated&#34;) print(&#34;main: data.x = {}&#34;.format(MyThread.data.x)) # main guard if __name__ == &#34;__main__&#34;: MyThread.main(sys.argv) Explanation In this example, we are creating a static instance of the MyData class, attached directly to the MyThread class and not a particular object, which can act as a shared memory object for this example. Then, in each of the threads, we are performing this three-step process:</description>
    </item>
    <item>
      <title>Summary</title>
      <link>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/11-summary/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/11-summary/index.html</guid>
      <description>In this chapter, we learned about processes and threads. A process is an instance of an application running on our computer, and it can be broken up into multiple threads of execution.&#xA;Creating threads is very simple - in most cases, we just need to define a function that is used as the starting point for the thread. However, in multithreaded programs, dealing with shared memory can be tricky, and if done incorrectly we can run into race conditions which cause our programs to possibly lose data.</description>
    </item>
  </channel>
</rss>