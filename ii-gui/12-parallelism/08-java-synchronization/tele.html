<!DOCTYPE html>

<html lang="en-us" dir="ltr" itemscope itemtype="http://schema.org/Article" data-r-output-format="html">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="height=device-height, width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <meta name="generator" content="Hugo 0.148.1">
    <meta name="generator" content="Relearn 8.0.0">
    <meta name="description" content="Next, let’s look at a quick example of a race condition in Java, just so we can see how it could occur in our code.
Poorly Designed Multithreading First, let’s consider this example:
public class MyData { public int x; } import java.lang.Runnable; import java.lang.Thread; import java.lang.InterruptedException; public class MyThread implements Runnable { private String name; private static MyData data; /** * Constructor. * * @param name the name of the thread */ public MyThread(String name) { this.name = name; } /** * Thread method. * * &lt;p&gt;This is called when the thread is started. */ @Override public void run() { for (int i = 0; i &lt; 3; i&#43;&#43;) { int y = data.x; // tell the OS it is ok to switch to another thread here Thread.yield(); data.x = y &#43; 1; System.out.println(this.name &#43; &#34; : data.x = &#34; &#43; data.x); } } /** * Main Method. */ public static void main(String[] args) { // create data data = new MyData(); // create threads Thread thread1 = new Thread(new MyThread(&#34;Thread 1&#34;)); Thread thread2 = new Thread(new MyThread(&#34;Thread 2&#34;)); Thread thread3 = new Thread(new MyThread(&#34;Thread 3&#34;)); // start threads System.out.println(&#34;main: starting threads&#34;); thread1.start(); thread2.start(); thread3.start(); // wait until all threads have terminated System.out.println(&#34;main: joining threads&#34;); try { thread1.join(); thread2.join(); thread3.join(); } catch (InterruptedException e){ System.out.println(&#34;main thread was interrupted&#34;); } System.out.println(&#34;main: all threads terminated&#34;); System.out.println(&#34;main: data.x = &#34; &#43; data.x); } } Explanation In this example, we are creating a static instance of the MyData class, which can act as a shared memory object for this example. Then, in each of the threads, we are performing this three-step process:">
    <meta name="author" content="Russell Feldhausen">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content="https://textbooks.cs.ksu.edu/cc410/images/hero.png">
    <meta name="twitter:title" content="Java Synchronization :: CC 410 Textbook">
    <meta name="twitter:description" content="Next, let’s look at a quick example of a race condition in Java, just so we can see how it could occur in our code.
Poorly Designed Multithreading First, let’s consider this example:
public class MyData { public int x; } import java.lang.Runnable; import java.lang.Thread; import java.lang.InterruptedException; public class MyThread implements Runnable { private String name; private static MyData data; /** * Constructor. * * @param name the name of the thread */ public MyThread(String name) { this.name = name; } /** * Thread method. * * &lt;p&gt;This is called when the thread is started. */ @Override public void run() { for (int i = 0; i &lt; 3; i&#43;&#43;) { int y = data.x; // tell the OS it is ok to switch to another thread here Thread.yield(); data.x = y &#43; 1; System.out.println(this.name &#43; &#34; : data.x = &#34; &#43; data.x); } } /** * Main Method. */ public static void main(String[] args) { // create data data = new MyData(); // create threads Thread thread1 = new Thread(new MyThread(&#34;Thread 1&#34;)); Thread thread2 = new Thread(new MyThread(&#34;Thread 2&#34;)); Thread thread3 = new Thread(new MyThread(&#34;Thread 3&#34;)); // start threads System.out.println(&#34;main: starting threads&#34;); thread1.start(); thread2.start(); thread3.start(); // wait until all threads have terminated System.out.println(&#34;main: joining threads&#34;); try { thread1.join(); thread2.join(); thread3.join(); } catch (InterruptedException e){ System.out.println(&#34;main thread was interrupted&#34;); } System.out.println(&#34;main: all threads terminated&#34;); System.out.println(&#34;main: data.x = &#34; &#43; data.x); } } Explanation In this example, we are creating a static instance of the MyData class, which can act as a shared memory object for this example. Then, in each of the threads, we are performing this three-step process:">
    <meta property="og:url" content="https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/08-java-synchronization/index.html">
    <meta property="og:site_name" content="CC 410 Textbook">
    <meta property="og:title" content="Java Synchronization :: CC 410 Textbook">
    <meta property="og:description" content="Next, let’s look at a quick example of a race condition in Java, just so we can see how it could occur in our code.
Poorly Designed Multithreading First, let’s consider this example:
public class MyData { public int x; } import java.lang.Runnable; import java.lang.Thread; import java.lang.InterruptedException; public class MyThread implements Runnable { private String name; private static MyData data; /** * Constructor. * * @param name the name of the thread */ public MyThread(String name) { this.name = name; } /** * Thread method. * * &lt;p&gt;This is called when the thread is started. */ @Override public void run() { for (int i = 0; i &lt; 3; i&#43;&#43;) { int y = data.x; // tell the OS it is ok to switch to another thread here Thread.yield(); data.x = y &#43; 1; System.out.println(this.name &#43; &#34; : data.x = &#34; &#43; data.x); } } /** * Main Method. */ public static void main(String[] args) { // create data data = new MyData(); // create threads Thread thread1 = new Thread(new MyThread(&#34;Thread 1&#34;)); Thread thread2 = new Thread(new MyThread(&#34;Thread 2&#34;)); Thread thread3 = new Thread(new MyThread(&#34;Thread 3&#34;)); // start threads System.out.println(&#34;main: starting threads&#34;); thread1.start(); thread2.start(); thread3.start(); // wait until all threads have terminated System.out.println(&#34;main: joining threads&#34;); try { thread1.join(); thread2.join(); thread3.join(); } catch (InterruptedException e){ System.out.println(&#34;main thread was interrupted&#34;); } System.out.println(&#34;main: all threads terminated&#34;); System.out.println(&#34;main: data.x = &#34; &#43; data.x); } } Explanation In this example, we are creating a static instance of the MyData class, which can act as a shared memory object for this example. Then, in each of the threads, we are performing this three-step process:">
    <meta property="og:locale" content="en_us">
    <meta property="og:type" content="article">
    <meta property="article:section" content="GUI">
    <meta property="article:modified_time" content="2023-01-19T16:21:53-06:00">
    <meta property="og:image" content="https://textbooks.cs.ksu.edu/cc410/images/hero.png">
    <meta itemprop="name" content="Java Synchronization :: CC 410 Textbook">
    <meta itemprop="description" content="Next, let’s look at a quick example of a race condition in Java, just so we can see how it could occur in our code.
Poorly Designed Multithreading First, let’s consider this example:
public class MyData { public int x; } import java.lang.Runnable; import java.lang.Thread; import java.lang.InterruptedException; public class MyThread implements Runnable { private String name; private static MyData data; /** * Constructor. * * @param name the name of the thread */ public MyThread(String name) { this.name = name; } /** * Thread method. * * &lt;p&gt;This is called when the thread is started. */ @Override public void run() { for (int i = 0; i &lt; 3; i&#43;&#43;) { int y = data.x; // tell the OS it is ok to switch to another thread here Thread.yield(); data.x = y &#43; 1; System.out.println(this.name &#43; &#34; : data.x = &#34; &#43; data.x); } } /** * Main Method. */ public static void main(String[] args) { // create data data = new MyData(); // create threads Thread thread1 = new Thread(new MyThread(&#34;Thread 1&#34;)); Thread thread2 = new Thread(new MyThread(&#34;Thread 2&#34;)); Thread thread3 = new Thread(new MyThread(&#34;Thread 3&#34;)); // start threads System.out.println(&#34;main: starting threads&#34;); thread1.start(); thread2.start(); thread3.start(); // wait until all threads have terminated System.out.println(&#34;main: joining threads&#34;); try { thread1.join(); thread2.join(); thread3.join(); } catch (InterruptedException e){ System.out.println(&#34;main thread was interrupted&#34;); } System.out.println(&#34;main: all threads terminated&#34;); System.out.println(&#34;main: data.x = &#34; &#43; data.x); } } Explanation In this example, we are creating a static instance of the MyData class, which can act as a shared memory object for this example. Then, in each of the threads, we are performing this three-step process:">
    <meta itemprop="dateModified" content="2023-01-19T16:21:53-06:00">
    <meta itemprop="wordCount" content="774">
    <meta itemprop="image" content="https://textbooks.cs.ksu.edu/cc410/images/hero.png">
    <title>Java Synchronization :: CC 410 Textbook</title>
    <link href="https://textbooks.cs.ksu.edu/cc410/ii-gui/12-parallelism/08-java-synchronization/index.html" rel="canonical" type="text/html" title="Java Synchronization :: CC 410 Textbook">
    <link href="/cc410/ii-gui/12-parallelism/08-java-synchronization/index.xml" rel="alternate" type="application/rss+xml" title="Java Synchronization :: CC 410 Textbook">
    <link href="/cc410/ii-gui/12-parallelism/08-java-synchronization/index.print.html" rel="alternate" type="text/html" title="Java Synchronization :: CC 410 Textbook">
    <link href="/cc410/ii-gui/12-parallelism/08-java-synchronization/embed.html" rel="alternate" type="text/html" title="Java Synchronization :: CC 410 Textbook">
    <link href="/cc410/images/favicon.ico?1758639063" rel="icon" type="image/x-icon" sizes="any">
    <link href="/cc410/css/auto-complete/auto-complete.min.css?1758639063" rel="stylesheet">
    <script src="/cc410/js/auto-complete/auto-complete.min.js?1758639063" defer></script>
    <script src="/cc410/js/search-lunr.min.js?1758639063" defer></script>
    <script src="/cc410/js/search.min.js?1758639063" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.index_js_url="/cc410/searchindex.en.js?1758639063";
    </script>
    <script src="/cc410/js/lunr/lunr.min.js?1758639063" defer></script>
    <script src="/cc410/js/lunr/lunr.stemmer.support.min.js?1758639063" defer></script>
    <script src="/cc410/js/lunr/lunr.multi.min.js?1758639063" defer></script>
    <script src="/cc410/js/lunr/lunr.en.min.js?1758639063" defer></script>
    <script>
      window.relearn = window.relearn || {};
      window.relearn.contentLangs=['en'];
    </script>
    <link href="/cc410/fonts/fontawesome/css/fontawesome-all.min.css?1758639063" rel="stylesheet" media="print" onload="this.media='all';this.onload=null;"><noscript><link href="/cc410/fonts/fontawesome/css/fontawesome-all.min.css?1758639063" rel="stylesheet"></noscript>
    <link href="/cc410/css/perfect-scrollbar/perfect-scrollbar.min.css?1758639063" rel="stylesheet">
    <link href="/cc410/css/theme.min.css?1758639063" rel="stylesheet">
    <link href="/cc410/css/format-html.min.css?1758639063" rel="stylesheet" id="R-format-style">
    <script>
      window.relearn = window.relearn || {};
      // configuration
      window.relearn.min = `.min`;
      window.relearn.path='\/ii-gui\/12-parallelism\/08-java-synchronization\/index.html';
      window.relearn.relBasePath='..\/..\/..';
      window.relearn.relBaseUri='..\/..\/..\/..';
      window.relearn.absBaseUri='https:\/\/textbooks.cs.ksu.edu\/cc410';
      window.relearn.disableAnchorCopy=false;
      window.relearn.disableAnchorScrolling=false;
      window.relearn.disableInlineCopyToClipboard=true;
      window.relearn.enableBlockCodeWrap=false;
      // legal
      window.relearn.getItem = (s,n) => {return s.getItem(n)};
      window.relearn.setItem = (s,n,v) => {return s.setItem(n,v)};
      window.relearn.removeItem = (s,n) => {return s.removeItem(n)};
      // translations
      window.T_Copy_to_clipboard = `Copy to clipboard`;
      window.T_Copied_to_clipboard = `Copied to clipboard!`;
      window.T_Copy_link_to_clipboard = `Copy link to clipboard`;
      window.T_Link_copied_to_clipboard = `Copied link to clipboard!`;
      window.T_Reset_view = `Reset view`;
      window.T_View_reset = `View reset!`;
      window.T_No_results_found = `No results found for "{0}"`;
      window.T_N_results_found = `{1} results found for "{0}"`;
      // variant stuff
      window.relearn.themevariants = [ 'light-theme' ];
      window.relearn.customvariantname = "my-custom-variant";
      // [x] russfeld
      window.relearn.writeVariant=false;
      window.relearn.changeVariant = function(variant) {
        var oldVariant = document.documentElement.dataset.rThemeVariant;
        window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
        document.documentElement.dataset.rThemeVariant = variant;
        if (oldVariant != variant) {
          document.dispatchEvent( new CustomEvent('themeVariantLoaded', { detail: { variant, oldVariant } }) );
          window.relearn.markVariant();
        }
      }
      window.relearn.markVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant");
        document.querySelectorAll(".R-variantswitcher select").forEach((select) => {select.value = variant;});
      }
      window.relearn.initVariant = function() {
        var variant = window.relearn.getItem(window.localStorage, window.relearn.absBaseUri + "/variant") ?? "";
        if( variant == window.relearn.customvariantname ){
        }else if( !variant || !window.relearn.themevariants.includes(variant) ){
          variant = window.relearn.themevariants[0];
          
          if (window.relearn.writeVariant) {
            window.relearn.setItem(window.localStorage, window.relearn.absBaseUri + "/variant", variant);
          }
        }
        document.documentElement.dataset.rThemeVariant = variant;
      }
      window.relearn.initVariant();
      window.relearn.markVariant();
    </script>
    <link href="/cc410/css/custom.css?1758639063" rel="stylesheet">
  </head>
  <body class="mobile-support html" data-url="/cc410/ii-gui/12-parallelism/08-java-synchronization/index.html">
    
    <div id="tele" class="tele mirror">
    
    <div id="R-body" class="default-animation">
      <div id="R-body-overlay"></div>
      
      
      
      <div id="R-main-overlay"></div>
      <main id="R-body-inner" class="highlightable ii-gui" tabindex="-1">
        <div class="flex-block-wrapper">
<article class="default">
  <header class="headline">
  </header>

<h1 id="java-synchronization">Java Synchronization</h1>

<p>Next, let&rsquo;s look at a quick example of a race condition in Java, just so we can see how it could occur in our code.</p>
<h2 id="poorly-designed-multithreading">Poorly Designed Multithreading</h2>
<p>First, let&rsquo;s consider this example:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyData</span> {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> x;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f92672">import</span> java.lang.Runnable;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.lang.Thread;
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> java.lang.InterruptedException;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MyThread</span> <span style="color:#66d9ef">implements</span> Runnable {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> String name;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> MyData data;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Constructor.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * @param name the name of the thread
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">MyThread</span>(String name) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Thread method.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * &lt;p&gt;This is called when the thread is started.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 3; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> data.<span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// tell the OS it is ok to switch to another thread here</span>
</span></span><span style="display:flex;"><span>            Thread.<span style="color:#a6e22e">yield</span>();
</span></span><span style="display:flex;"><span>            data.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; : data.x = &#34;</span> <span style="color:#f92672">+</span> data.<span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     * Main Method.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span>(String<span style="color:#f92672">[]</span> args) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// create data</span>
</span></span><span style="display:flex;"><span>        data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> MyData();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// create threads</span>
</span></span><span style="display:flex;"><span>        Thread thread1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(<span style="color:#66d9ef">new</span> MyThread(<span style="color:#e6db74">&#34;Thread 1&#34;</span>));
</span></span><span style="display:flex;"><span>        Thread thread2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(<span style="color:#66d9ef">new</span> MyThread(<span style="color:#e6db74">&#34;Thread 2&#34;</span>));
</span></span><span style="display:flex;"><span>        Thread thread3 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Thread(<span style="color:#66d9ef">new</span> MyThread(<span style="color:#e6db74">&#34;Thread 3&#34;</span>));
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// start threads</span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;main: starting threads&#34;</span>);
</span></span><span style="display:flex;"><span>        thread1.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        thread2.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        thread3.<span style="color:#a6e22e">start</span>();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// wait until all threads have terminated</span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;main: joining threads&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>            thread1.<span style="color:#a6e22e">join</span>();
</span></span><span style="display:flex;"><span>            thread2.<span style="color:#a6e22e">join</span>();
</span></span><span style="display:flex;"><span>            thread3.<span style="color:#a6e22e">join</span>();
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">catch</span> (InterruptedException e){
</span></span><span style="display:flex;"><span>            System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;main thread was interrupted&#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;main: all threads terminated&#34;</span>);
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;main: data.x = &#34;</span> <span style="color:#f92672">+</span> data.<span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<h4 id="explanation">Explanation</h4>
<p>In this example, we are creating a <code>static</code> instance of the <code>MyData</code> class, which can act as a shared memory object for this example. Then, in each of the threads, we are performing this three-step process:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> data.<span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span><span style="color:#75715e">// tell the OS it is ok to switch to another thread here</span>
</span></span><span style="display:flex;"><span>Thread.<span style="color:#a6e22e">yield</span>();
</span></span><span style="display:flex;"><span>data.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> 1;</span></span></code></pre></div>
<p>Just as we saw in the earlier example, we are reading the current value stored in <code>data.x</code> into a variable <code>y</code>. Then, we are using the <code>Thread.yield()</code> method to tell the operating system that it is allowed to switch away from this thread at this point. In practice, we typically wouldn&rsquo;t use this method at all, but it is helpful for testing. In fact, <code>Thread.yield()</code> is effectively the same as calling <code>Thread.sleep(0)</code> - we are telling the operating system to put this thread to sleep, but then immediately add it back to the list of threads to be scheduled on the processor. Finally, we update the value stored in <code>data.x</code> to be one larger than the value we saved earlier.</p>
<p>In effect, this is essentially the Java code needed to reproduce the example we saw earlier in this class.</p>
<h4 id="execution">Execution</h4>
<p>So, what happens when we run this code? As it turns out, sometimes we&rsquo;ll see it get a different result than the one we expect:</p>
<p><a href="#R-image-87690a95a234875ed2e7273e615dea26" class="lightbox-link"><img alt="Race Condition in Java" class="border lazy lightbox figure-image" loading="lazy" src="/cc410/images/10/java_race.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-87690a95a234875ed2e7273e615dea26"><img alt="Race Condition in Java" class="border lazy lightbox lightbox-image" loading="lazy" src="/cc410/images/10/java_race.png"></a></p>
<p>Uh oh! This is exactly what a race condition looks like in practice. In the screenshot on the right, we see that two threads set the same value into <code>data.x</code>, which means that they were running at the same time.</p>
<h2 id="java-synchronized-blocks">Java Synchronized Blocks</h2>
<p>To fix this, Java includes couple of special methods for dealing with synchronization. First, we can use the <code>synchronized</code> statement, which is simply a wrapper around a block of code that we&rsquo;d like to be <strong>atomic</strong>. An atomic block is one that shouldn&rsquo;t be broken apart and interrupted by other threads accessing the same object. In effect, the <code>synchronized</code> statement will handle acquiring and releasing a lock for us, based on the item used in the statement.</p>
<p>So, in this example, we can update the <code>run()</code> method to use a <code>synchronized</code> statement:</p>
<div class="highlight" dir="auto"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">run</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0; i <span style="color:#f92672">&lt;</span> 3; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">synchronized</span>(data) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> data.<span style="color:#a6e22e">x</span>;
</span></span><span style="display:flex;"><span>                Thread.<span style="color:#a6e22e">yield</span>();
</span></span><span style="display:flex;"><span>                data.<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> y <span style="color:#f92672">+</span> 1;
</span></span><span style="display:flex;"><span>                System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">name</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; : data.x = &#34;</span> <span style="color:#f92672">+</span> data.<span style="color:#a6e22e">x</span>);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            Thread.<span style="color:#a6e22e">yield</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }</span></span></code></pre></div>
<p>Here, the <code>synchronized</code> statement creates a <strong>lock</strong> that is associated with the <code>data</code> object in memory. Only one thread can hold that lock at a time, and by associating it with an object, we can easily keep track of which thread is able to access that object.</p>
<p>Now, when we execute that program, we&rsquo;ll always get the correct answer!</p>
<p><a href="#R-image-a1372b3b76131bd2b05267a2e5ce531e" class="lightbox-link"><img alt="Synchronized in Java" class="border lazy lightbox figure-image" loading="lazy" src="/cc410/images/10/java_synch.png" style=" height: auto; width: auto;"></a>
<a href="javascript:history.back();" class="lightbox-back" id="R-image-a1372b3b76131bd2b05267a2e5ce531e"><img alt="Synchronized in Java" class="border lazy lightbox lightbox-image" loading="lazy" src="/cc410/images/10/java_synch.png"></a></p>

<details open class=" box cstyle notices info">
  <summary class="box-label" tabindex="-1">
    <i class="fa-fw fas fa-info-circle"></i> 
    Not Always Random?
  </summary>
  <div class="box-content">
<p>In fact, to get the threads interleaved as shown in this screenshot, we had to add additional <code>Thread.sleep()</code> statements to the code! Otherwise, the program always seemed to schedule the threads in the same order on Codio. We cannot guarantee it will always happen like that, but it is an interesting quirk you can observe in multithreaded code. In practice, sometimes race conditions may only happen once in a million operations, making them extremely difficult to debug when they happen.</p>
  </div>
</details>

  <footer class="footline">
  </footer>
</article>
        </div>
      </main>
      
      
      
    </div>
    <script src="/cc410/js/clipboard/clipboard.min.js?1758639063" defer></script>
    <script src="/cc410/js/perfect-scrollbar/perfect-scrollbar.min.js?1758639063" defer></script>
    <script src="/cc410/js/theme.min.js?1758639063" defer></script>
      
      
      
    </div> 
  <script src="/cc410/js/tele-scroll.min.js?1758639063" defer></script>
  </body>
</html>
