<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Inheritance &amp; Polymorphism :: CC 410 Textbook</title>
    <link>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/index.html</link>
    <description>Like superclass, like subclass! Now, with interfaces!</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 17 Jun 2024 14:13:48 -0500</lastBuildDate>
    <atom:link href="https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/01-introduction/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/01-introduction/index.html</guid>
      <description>Content Note Much of the content in this chapter was adapted from Nathan Bean’s CIS 400 course at K-State, with the author’s permission. That content is licensed under a Creative Commons BY-NC-SA license.&#xA;The term polymorphism means many forms. In computer science, it refers to the ability of a single symbol (i.e. a function or class name) to represent multiple types. Some form of polymorphism can be found in nearly all programming languages.</description>
    </item>
    <item>
      <title>Types</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/02-types/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/02-types/index.html</guid>
      <description>Video Materials&#xA;Before we can discuss polymorphism in detail, we must first understand the concept of types. In computer science, a type is a way of categorizing a variable by its storage strategy, i.e., how it is represented in the computer’s memory. It also defines how the value can be treated and what operations can be performed on it.</description>
    </item>
    <item>
      <title>Interfaces</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/03-interfaces/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/03-interfaces/index.html</guid>
      <description>Video Materials&#xA;If we think back to the concept of message passing in object-oriented languages, it can be useful to think of the collection of public methods available in a class as an interface, i.e., a list of messages you can dispatch to an object created from that class. When you were first learning a language (and probably even now), you find yourself referring to these kinds of lists, usually in the language’s documentation:</description>
    </item>
    <item>
      <title>Java Interfaces</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/04-java-interfaces/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/04-java-interfaces/index.html</guid>
      <description>Video Materials&#xA;The Java programming language includes direct support for the creation of interfaces via the interface keyword. We’ve already seen one example of an interface created in Java, but let’s look at another example and dissect it a bit.&#xA;Interface Example Here is a simple interface for a set of classes that are based on the Collection interface in Java 8:</description>
    </item>
    <item>
      <title>Java Inheritance</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/05-java-inheritance/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/05-java-inheritance/index.html</guid>
      <description>In an object-oriented language, inheritance is a mechanism for deriving part of a class definition from another existing class definition. This allows the programmer to “share” code between classes, reducing the amount of code that must be written.&#xA;Consider the Student class we created earlier:&#xA;public class Student { private int creditPoints; private int creditHours; private String first; private String last; // accessor methods for first and last omitted public Student(String first, String last) { this.first = first; this.last = last; } /** * Gets the student&#39;s grade point average. */ public double getGPA() { return ((double) creditPoints) / creditHours; } /** * Records a final grade for a course taken by this student. * * @param grade the grade earned by the student * @param hours the number of credit hours in the course */ public void addCourseGrade(Grade grade, int hours) { this.creditHours += hours; switch(grade) { case A: this.creditPoints += 4 * hours; break; case B: this.creditPoints += 3 * hours; break; case C: this.creditPoints += 2 * hours; break; case D: this.creditPoints += 1 * hours; break; case F: this.creditPoints += 0 * hours; break; } } } This would work well for representing a student. But what if we are representing multiple kinds of students, like undergraduate and graduate students? We’d need separate classes for each, but both would still have names and calculate their GPA the same way. So, it would be handy if we could say “an undergraduate is a student, and has all the properties and methods a student has” and “a graduate student is a student, and has all the properties and methods a student has.” This is exactly what inheritance does for us, and we often describe it as an is-a relationship. We distinguish this from the interface mechanism we looked at earlier by saying it is a strong is-a relationship, as an Undergraduate student is, for all purposes, also a Student.</description>
    </item>
    <item>
      <title>Python Interfaces</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/06-python-interfaces/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/06-python-interfaces/index.html</guid>
      <description>Video Materials&#xA;The Python programming language doesn’t include direct support for interfaces in the same way as other object-oriented programming languages. However, it is possible to construct the same functionality in Python with just a little bit of work. For the full context, check out Implementing in Interface in Python from Real Python. It includes a much deeper discussion of the different aspects of this code and why we use it.</description>
    </item>
    <item>
      <title>Python Inheritance</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/07-python-inheritance/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/07-python-inheritance/index.html</guid>
      <description>In an object-oriented language, inheritance is a mechanism for deriving part of a class definition from another existing class definition. This allows the programmer to “share” code between classes, reducing the amount of code that must be written.&#xA;Consider the Student class we created earlier:&#xA;class Student: def __init__(self, first: str, last: str) -&gt; None: self.__first: str = first self.__last: str = last self.__credit_points: int = 0 self.__credit_hours: int = 0 # properties for first and last omitted @property def gpa(self) -&gt; float: &#34;&#34;&#34;Gets the student&#39;s grade point average. &#34;&#34;&#34; return self.__credit_points / self.__credit_hours def add_course_grade(self, grade: Grade, hours: int) -&gt; None: &#34;&#34;&#34;Records a final grade for a course taken by this student. Args grade: the grade earned by the student hours: the number of credit hours in the course &#34;&#34;&#34; self.__credit_hours += hours if grade == Grade.A: self.__credit_points += 4 * hours elif grade == Grade.B: self.__credit_points += 3 * hours elif grade == Grade.C: self.__credit_points += 2 * hours elif grade == Grade.D: self.__credit_points += 1 * hours elif grade == Grade.F: self.__credit_points += 0 * hours This would work well for representing a student. But what if we are representing multiple kinds of students, like undergraduate and graduate students? We’d need separate classes for each, but both would still have names and calculate their GPA the same way. So, it would be handy if we could say “an undergraduate is a student, and has all the properties and methods a student has” and “a graduate student is a student, and has all the properties and methods a student has.” This is exactly what inheritance does for us, and we often describe it as an is-a relationship. We distinguish this from the interface mechanism we looked at earlier by saying it is a strong is-a relationship, as an Undergraduate student is, for all purposes, also a Student.</description>
    </item>
    <item>
      <title>Type Checking &amp; Conversion</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/08-type-checking-conversion/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/08-type-checking-conversion/index.html</guid>
      <description>You have probably used casting to convert numeric values from one type to another, i.e.:&#xA;​ Java Python double a = 5.5; int b = (int) a; a: float = 5.5&#xD;b: int = int(a) What you are actually doing when you cast is transforming a value from one type to another. In the first case, you are taking the value of a, which is the floating-point value 5.5, and converting it to the equivalent integer value 5.</description>
    </item>
    <item>
      <title>Message Dispatching</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/09-message-dispatching/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/09-message-dispatching/index.html</guid>
      <description>Video Materials&#xA;The term dispatch refers to how a language decides which polymorphic operation (a method or function) a message should trigger.&#xA;Consider polymorphic functions in Java, also known as method overloading, where multiple methods use the same name but have different parameters. Here’s an example for calculating the rounded sum of an array of numbers:</description>
    </item>
    <item>
      <title>Summary</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/10-summary/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/06-inheritance-polymorphism/10-summary/index.html</guid>
      <description>In this chapter, we explored the concept of types and discussed how variables are specific types that can be explicitly or implicitly declared. We saw how in a statically-typed language (like Java), variables are not allowed to change types, though they can do so in a dynamically-typed language like Python. We also discussed how casting can convert a value stored in a variable into a different type. Implicit casts can happen automatically, but explicit casts must be indicated by the programmer using a cast operator, as the cast could result in loss of precision or the throwing of an exception.</description>
    </item>
  </channel>
</rss>