<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Test Doubles :: CC 410 Textbook</title>
    <link>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/index.html</link>
    <description>Mimicking and making a “mock&#34;ery of testing!</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 17 Jun 2024 14:13:48 -0500</lastBuildDate>
    <atom:link href="https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Introduction</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/01-introduction/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/01-introduction/index.html</guid>
      <description>Earlier in this course, we learned about unit testing and how we can write code to help us verify that parts of our program are performing as intended. However, what if the portion of our program we’d like to test depends on other parts working correctly? In that case, any errors in our tests might be due to our code having a bug, but it could also be due to a bug in another part of the program that our code depends on.</description>
    </item>
    <item>
      <title>Need for Test Doubles</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/02-need-test-doubles/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/02-need-test-doubles/index.html</guid>
      <description>Video Materials&#xA;As we build larger and larger applications, we may find that it becomes more and more difficult to see the entire application as a whole. Instead, it helps to think of the application as many different modules, and each module interacts with others based on their publicly available methods, which make up the application programming interface or API of the module.</description>
    </item>
    <item>
      <title>Arrange, Act, Assert</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/03-arrange-act-assert/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/03-arrange-act-assert/index.html</guid>
      <description>Most of our unit tests have been following a particular pattern, commonly called arrange, act, assert. Let’s quickly review that pattern, as it is very important to understand how it integrates with the use of test doubles later in this chapter.&#xA;A simple unit test following the arrange, act, assert pattern consists of three major steps:&#xA;Arrange - first, the objects to be tested and any supporting data is created within the test. Act - secondly, the operation being tested is carried out, usually by calling one or more methods. Assert - once the operation is complete, we use assertions to verify that the outcome of the operation is correct. In some instances, we may also include a fourth step, Teardown, which is used to reset the state back to its initial state, if needed. There are times when our arrange step makes some changes to the environment that must be reversed before we can continue.</description>
    </item>
    <item>
      <title>Stubs</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/04-stubs/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/04-stubs/index.html</guid>
      <description>Video Materials&#xA;Inconsistent Naming Unfortunately, the naming of many of these test doubles, such as stubs, mocks, and fakes, are used either inconsistently or interchangeably within different systems, documentation, and other resources. I’m going to stick to one particular naming scheme, which is best described in the resources linked earlier in this chapter. However, in practice, these terms may be used differently in different areas.</description>
    </item>
    <item>
      <title>Fakes</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/05-fakes/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/05-fakes/index.html</guid>
      <description>Another commonly used test double is a fake, sometimes referred to as a fake object. A fake is an object that implements the same external interface that the real object would implement - it includes all of the same publicly available methods and attributes. However, the implementations of those methods may take certain shortcuts to mimic pieces of functionality that are not really needed in order to produce valid results. (Many test frameworks use the term mock object for the same concept; however, we’ll use that term on the next page for a slightly different use.)</description>
    </item>
    <item>
      <title>Mocks</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/06-mocks/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/06-mocks/index.html</guid>
      <description>The third type of test double we’ll cover is the mock object, sometimes referred to as a test spy. A mock object is typically used to verify that our code performs the correct actions on other parts of the system. Usually, the mock object will simply listen for any incoming method calls, and then once our action is complete we can verify that the correct methods were called with the correct inputs by examining our mock object.</description>
    </item>
    <item>
      <title>Test Doubles in JUnit</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/07-junit-test-doubles/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/07-junit-test-doubles/index.html</guid>
      <description>Video Materials&#xA;To create test doubles in JUnit, we’ll rely on a separate library called Mockito. Mockito is a framework for creating mock objects in Java that works well with JUnit, and has become one of the most commonly used tools for this task.&#xA;Installing Mockito in Gradle To install Mockito, we just update the testImplementation line in our build.gradle file to include both the mockito-inline library, as well as the mockito-junit-jupiter library that allows Mockito and JUnit to work together seamlessly.</description>
    </item>
    <item>
      <title>Test Doubles in pytest</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/08-pytest-test-doubles/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/08-pytest-test-doubles/index.html</guid>
      <description>Video Materials&#xA;To create test doubles in Python, we’ll rely on the built-in unittest.mock library. It includes lots of quick and easy methods for creating fake objects in Python, and it is compatible with the pytest testing framework that we’re already using.&#xA;Adding Mocks to a Test Class There are many different ways to use the unittest.mock library. One of the easiest ways is to import the patch annotation</description>
    </item>
    <item>
      <title>Dependency Injection</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/09-dependency-injection/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/09-dependency-injection/index.html</guid>
      <description>One other important topic to cover in unit tests is dependency injection. In short, dependency injection is a way that we can build our classes so that the objects they depend on can be added to the class from outside. In that way, we can change them as needed in our unit tests as a way to test functionality using test doubles.&#xA;Consider the following example:&#xA;​ Java Python public class Teacher { private Gradebook gradebook; private List&lt;Student&gt; studentList; public Teacher() { this.gradebook = new Gradebook(&#34;Course Name&#34;); this.studentList = new List&lt;&gt;(); } public void addStudent(Student s) { this.studentList.add(s); } public void submitGrades() { for (Student s : this.studentList) { this.gradebook.gradeStudent(s); } } } class Teacher: def __init__(self) -&gt; None: self.__gradebook: Gradebook = Gradebook() self.__student_list: List[Student] = list() def add_student(self, s: Student) -&gt; None: self.__student_list.append(s) def submit_grades(self) -&gt; None: for s in self.__student_list: self.__gradebook.grade_student(s) In this Teacher class, we see a private Gradebook instance. That instance is not accessible outside the class, so we cannot directly interact with it in our unit tests, at least without violating the security principles of the class it is in. So, if we want to test that the submitGrades() method properly grades every student in the studentList, we would need some way to replace the gradebook attribute with a test double.</description>
    </item>
    <item>
      <title>Summary</title>
      <link>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/10-summary/index.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://textbooks.cs.ksu.edu/cc410/i-oop/10-test-doubles/10-summary/index.html</guid>
      <description>In this chapter, we learned about test doubles and how they can use them in our unit tests to mimic functionality from other parts of our program. In short, there are three different common types of test doubles:&#xA;stubs - methods that mimic actual methods fakes - objects that mimic actual objects mocks - objects that record operations performed on it We also explored how we can use these in our code both Java and Python. Finally, we learned about dependency injection and how we can use that technique to place our test doubles directly in our classes. Now, we’ll be able to update the unit tests in our ongoing project to help separate the classes being tested from other classes that it depends on.</description>
    </item>
  </channel>
</rss>