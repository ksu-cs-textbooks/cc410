<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title></title>
    <link>https://textbooks.cs.ksu.edu/cc410/i-oop/09-design-patterns/07-iterator/video/slides/index.html</link>
    <description>Iterator Pattern Make a Class Iterable Use with For Each Loops Act Like a Collection Iterator Class to Keep Track of Location Typically Includes next Method Defined Way To Find End Other Methods May Be Included Iterable Interface class CrayonBox implements Iterable[Crayon]:&#xA;List[Crayon] contents&#xA;function addCrayon(Crayon c): contents.add(c)&#xA;function getIterator(): return contents.getIterator()&#xA;function get(int i): return contents[i]&#xA;function contains(Crayon c): return contents.contains(c)&#xA;function size(): return contents.size() Using an Iterable class Main:&#xA;function main(): CrayonBox box = CrayonBoxFactorySingleton.getInstance().getBox(16) //get iterator and print for Crayon c in box: print(c.color) Iterator Pattern Offload Most of Work to Underlying Collection Implement Helpful Collection Methods Don&#39;t Reinvent the Wheel Template Method Pattern Define Method Structure in Parent Override Portions in Child Same Basic Steps, Different Details Parent Class abstract class Recipe:&#xA;function bakeSomething(): gatherIngredients() combineIngredients() putInOven()&#xA;abstract function gatherIngredients() abstract function combineIngredients() abstract function putInOven() Child Class class Cake inherits Recipe:&#xA;function gatherIngredients(): getFlour() getSugar() getEggs() getButter()&#xA;function combineIngredients() creamEggsAndButter() addSugar() addFlour()&#xA;function putInOven() setOven(350) setTimer(30)</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://textbooks.cs.ksu.edu/cc410/i-oop/09-design-patterns/07-iterator/video/slides/index.xml" rel="self" type="application/rss+xml" />
  </channel>
</rss>